@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.Extensions.Options
@using Starbender.BlobStorage.Contracts
@using SixLabors.ImageSharp
@using SixLabors.ImageSharp.Processing
@using SixLabors.ImageSharp.Formats.Png

@inject IRecipeAppService RecipeService

@inherits RecipeComponentBase

@implements IDisposable

<MudPaper
    MinWidth="@WidthPx"
    MinHeight="@HeightPx"
    Class="pa-2 d-flex justify-center align-center"
    Outlined="true"
    Style=@($"width:{WidthPx}; height:{HeightPx}; position:relative;")>

    @if (_isBusy)
    {
        <div style=@($"width:{WidthPx}; height:{HeightPx};position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,0.6);z-index:2;")>
            <MudProgressCircular Indeterminate="true" />
        </div>
    }
    else if (HasContent)
    {
        <MudImage Width="@Width" Height="@Height" Src="@_imageDataUrl" Alt="@Alt" Style=@($"width:{WidthPx}; height:{HeightPx}; object-fit:contain;") />
    }
    else
    {
        <MudText Align="Align.Center" Typo="Typo.body2">@(IsEditable ? "Drop an image or click to upload" : "No Image")</MudText>
    }

    @if (IsEditable)
    {
        <!-- Optional: click-to-upload as fallback -->
        <InputFile
            OnChange="OnPickFile"
            accept="image/*"
            style="position:absolute;inset:0;opacity:0;cursor:pointer;" />
    }

</MudPaper>

@code {
    // Note: Image content is always assumed to be "image/png"
    public const string ContentType = "image/png";
    public const int MaxFileSize = 10 * 1024 * 1024;

    [Inject] IOptions<RecipeAppOptions> Options { get; init; } = null!;
    [Inject] IBlobContainerFactory ContainerFactory { get; init; } = null!;

    [Parameter] public BlobContentDto BlobContent { get; set; } = new();
    [Parameter] public EventCallback<BlobContentDto> BlobContentChanged { get; set; }

    [Parameter] public int Width { get; set; } = 150;
    [Parameter] public int Height { get; set; } = 150;
    [Parameter] public string? Alt { get; set; }
    [Parameter] public bool IsEditable { get; set; }

    private bool _isBusy;
    private string? _imageDataUrl;
    private readonly CancellationTokenSource _componentCts = new();
    private IBlobContainer? _container = null;
    private BlobContentDto _image = new();
    private RecipeAppOptions _options = new();

    private string WidthPx => $"{Width}px";
    private string HeightPx => $"{Height}px";
    private bool HasContent => _image.Content.Length > 0 && !string.IsNullOrWhiteSpace(_imageDataUrl);

    protected override Task OnInitializedAsync()
    {
        _options = Options.Value;
        _container = ContainerFactory.GetContainer(_options.ImageContainerId)
            ?? throw new Exception($"No Recipe Image container found. ({_options.ImageStoreType}.{_options.ImageContainerId})");

        return base.OnInitializedAsync();
    }

    protected override async Task OnParametersSetAsync()
    {
        _image = new BlobContentDto()
            {
            Id = BlobContent.Id,
            BlobId = BlobContent.BlobId,
            Checksum = BlobContent.Checksum,
            ContainerId = BlobContent.ContainerId,
            Content = BlobContent.Content.ToArray(),
            ContentType = BlobContent.ContentType,
            Size = BlobContent.Size,
            StoreType = BlobContent.StoreType
            };

        _imageDataUrl = $"data:{_image.ContentType};base64,{Convert.ToBase64String(_image.Content)}";
    }

    private async Task OnPickFile(InputFileChangeEventArgs e)
    {
        if (!IsEditable || e.File is null || _componentCts.IsCancellationRequested)
        {
            return;
        }

        try
        {
            _isBusy = true;
            await UpdateContent(e.File);
        }
        catch (OperationCanceledException) when (_componentCts.IsCancellationRequested)
        {
            // Ignore cancellation during disposal/navigation.
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Image update failed: {ex.Message}", Severity.Error);
        }
        finally
        {
            _isBusy = false;
        }
    }

    private async Task UpdateContent(IBrowserFile file)
    {
        if (_container == null)
        {
            throw new Exception("No image store available");
        }

        using var stream = file.OpenReadStream(maxAllowedSize: MaxFileSize, _componentCts.Token);

        using var ms = new MemoryStream();

        await stream.CopyToAsync(ms);

        var fileBytes = ms.ToArray();
        var pngBytes = ResizePng(fileBytes, Width, Height);


        if (string.IsNullOrWhiteSpace(_image.BlobId))
        {
            _image = await _container.CreateContentAsync(pngBytes, ContentType, _componentCts.Token);
        }
        else
        {
            _image = await _container.UpdateContentAsync(_image.BlobId, pngBytes, ContentType, _componentCts.Token);
        }

        await BlobContentChanged.InvokeAsync(_image);
    }

    public void Dispose()
    {
        if (_componentCts.IsCancellationRequested)
        {
            return;
        }

        _componentCts.Cancel();
        _componentCts.Dispose();
    }

    private byte[] ResizePng(byte[] inputBytes, int width, int height)
    {
        using var image = Image.Load(inputBytes);
        image.Mutate(x => x.Resize(width, height));

        using var ms = new MemoryStream();
        image.Save(ms, new PngEncoder());

        return ms.ToArray();
    }
}
